# ğŸ–¥ï¸ OS Discovery â€” Banner Grabbing & OS Fingerprinting
### CEH v13 Â· Module 03: Scanning Networks

> **About these notes:** A practical, exam-ready reference on OS discovery â€” covering banner grabbing mechanics, active vs. passive fingerprinting, TCP/IP stack analysis, tools, and CEH exam traps.

---

## ğŸ“‘ Table of Contents

1. [What is OS Discovery?](#1-what-is-os-discovery)
2. [Where It Fits in the Scanning Workflow](#2-where-it-fits-in-the-scanning-workflow)
3. [Why OS Discovery Matters](#3-why-os-discovery-matters)
4. [Two Primary Methods Overview](#4-two-primary-methods-overview)
5. [Banner Grabbing](#5-banner-grabbing)
   - [How It Works](#ï¸-how-banner-grabbing-works)
   - [Tools & Commands](#ï¸-banner-grabbing-tools--commands)
   - [Advantages & Limitations](#-advantages--limitations)
6. [OS Fingerprinting](#6-os-fingerprinting)
   - [How Fingerprinting Works](#-why-fingerprinting-works--the-tcp-ip-stack-secret)
   - [Active Fingerprinting](#-active-fingerprinting)
   - [Passive Fingerprinting](#-passive-fingerprinting)
7. [TCP/IP Stack Indicators â€” What Tools Analyze](#7-tcpip-stack-indicators--what-tools-analyze)
8. [Common OS TTL & Window Size Signatures](#8-common-os-ttl--window-size-signatures)
9. [Nmap OS Detection Workflow](#9-nmap-os-detection-workflow)
10. [Factors Affecting OS Detection Accuracy](#10-factors-affecting-os-detection-accuracy)
11. [OS Discovery Tools](#11-os-discovery-tools)
12. [Banner Grabbing vs. OS Fingerprinting â€” Comparison](#12-banner-grabbing-vs-os-fingerprinting--comparison)
13. [CEH Exam Traps & Tips](#13-ceh-exam-traps--tips)

---

## 1. What is OS Discovery?

**OS Discovery** is the process of identifying the **operating system, version, and system architecture** running on a target machine â€” also known in CEH terminology as **fingerprinting**.

Attackers perform OS discovery **after port and service discovery** to select the right OS-specific exploits and tailor their attack strategy for precision.

> ğŸ§  **Mental Model â€” The Scanning Chain:**
> ```
> Host Discovery   â†’ "Who is alive?"
> Port Discovery   â†’ "What doors are open?"
> OS Discovery     â†’ "What exact system am I attacking?"
> ```

---

## 2. Where It Fits in the Scanning Workflow

```
Footprinting (Passive Recon)
         â†“
Host Discovery
         â†“
Port & Service Discovery
         â†“
OS Discovery     â† â˜… YOU ARE HERE
         â†“
Vulnerability Analysis
         â†“
Exploitation
```

> ğŸ“Œ **CEH Sequence Rule:** OS discovery always comes **after** port scanning. Without open/closed ports, OS fingerprinting has nothing to analyze.

---

## 3. Why OS Discovery Matters

Different operating systems have fundamentally different vulnerabilities, patch cycles, and exploitation paths. Knowing the OS lets the attacker operate with precision.

| Attacker Goal | How OS Knowledge Helps |
|--------------|------------------------|
| **Choose the right exploit** | CVEs and exploits are OS and version specific |
| **Identify OS-specific vulnerabilities** | Windows â†’ SMB; Linux â†’ sudo misconfigs, etc. |
| **Tailor attack strategies** | Different post-exploitation tools per OS |
| **Increase attack success rate** | Avoids running incompatible exploits |
| **Reduce noise** | Fewer failed attempts = less IDS alerting |

> ğŸ’¡ **Real-World Example:** Detecting Windows XP SP3 â†’ immediate EternalBlue candidate. Detecting Ubuntu 20.04 â†’ check sudo CVEs, dirty pipe, polkit. The OS shapes the **entire** attack path.

---

## 4. Two Primary Methods Overview

| Method | How It Works | Stealth | Accuracy |
|--------|-------------|:-------:|:--------:|
| **Banner Grabbing** | Reads the text banner a service announces upon connection | ğŸŸ¡ Moderate | ğŸŸ¡ Medium |
| **OS Fingerprinting** | Analyzes TCP/IP stack behavior â€” no banner needed | ğŸŸ¢ High (passive) | ğŸŸ¢ High |

> ğŸ’¡ Fingerprinting is more reliable because banners can be **disabled or spoofed**. TCP/IP stack behavior cannot easily be faked.

---

## 5. Banner Grabbing

### ğŸ“Œ What Is It?

**Banner grabbing** extracts service and system information by reading the **banner** â€” the identifying text a network service sends automatically when a client connects.

Many services are configured to announce themselves, often revealing far more than intended.

### âš™ï¸ How Banner Grabbing Works

```
Step 1:  Attacker connects to an open port (e.g., port 80, 22, 21, 25)
              â†“
Step 2:  Service automatically sends its banner upon connection
              â†“
Step 3:  Attacker reads and analyzes the banner text
              â†“
Step 4:  Extracts:
          â”œâ”€â”€ Application name  (Apache, OpenSSH, Postfix, IIS...)
          â”œâ”€â”€ Version number    (2.4.49, 8.2p1, 3.5...)
          â””â”€â”€ Underlying OS     (Ubuntu, Debian, Windows Server...)
```

### ğŸ“Š Example Banners and What They Reveal

| Banner Received | Information Extracted |
|----------------|-----------------------|
| `Apache/2.4.49 (Ubuntu)` | Apache web server, version 2.4.49, running on Ubuntu |
| `OpenSSH_8.2p1 Ubuntu-4ubuntu0.5` | OpenSSH 8.2 on Ubuntu â€” check for CVE-2021-28041 |
| `220 mail.example.com ESMTP Postfix` | Postfix mail server â€” may reveal hostname |
| `Microsoft-IIS/10.0` | IIS 10.0 â†’ Windows Server 2016/2019 |
| `SSH-2.0-OpenSSH_7.4` | Old OpenSSH â€” CVE-2018-15473 username enumeration |

### ğŸ› ï¸ Banner Grabbing Tools & Commands

#### ğŸ”¹ Netcat (nc) â€” The Swiss Army Knife

```bash
# Connect to HTTP port and read banner
nc -nv <target> 80
HEAD / HTTP/1.0     # then press Enter twice

# Connect to FTP server
nc -nv <target> 21

# Connect to SMTP
nc -nv <target> 25
```

#### ğŸ”¹ Telnet â€” Classic Method

```bash
telnet <target> 80
telnet <target> 22
telnet <target> 25
```

#### ğŸ”¹ Nmap Service Version Detection â€” Automated Banner Grabbing

```bash
nmap -sV <target>
```

Increase probe intensity for more aggressive banner extraction:
```bash
nmap -sV --version-intensity 9 <target>
```

#### ğŸ”¹ curl â€” HTTP Banner & Header Extraction

```bash
# Grab HTTP response headers
curl -I http://<target>

# Show verbose with full server response
curl -v http://<target>
```

#### ğŸ”¹ Wget â€” Alternative HTTP Banner Grab

```bash
wget --server-response -q --spider http://<target>
```

#### ğŸ”¹ Python â€” Programmatic Banner Grabbing

```python
import socket

target = "10.10.1.11"
port = 80

s = socket.socket()
s.connect((target, port))
s.send(b"HEAD / HTTP/1.0\r\n\r\n")
banner = s.recv(1024)
print(banner.decode())
s.close()
```

### âœ… Advantages & Limitations

| Advantages | Limitations |
|------------|-------------|
| Simple â€” requires no special tools | Banners can be **disabled** by admins |
| Fast â€” immediate results on connection | Banners can be **spoofed** to mislead |
| Low traffic â€” minimal footprint | Not all services reveal the OS |
| Works with any service that sends text | May be **blocked** by WAF or firewall |
| Requires no root privileges | Version info may be **falsified** |

> ğŸ¯ **CEH Examiner Tip:** Banner grabbing is **not always reliable** â€” this exact statement appears in exam questions. Spoofed banners are a common defensive countermeasure.

---

## 6. OS Fingerprinting

### ğŸ“Œ What Is It?

**OS fingerprinting** identifies the operating system by analyzing **TCP/IP stack behavior** â€” not banners. Every OS implements the TCP/IP protocol suite slightly differently, creating a unique "fingerprint."

> ğŸ’¡ Even if banners are disabled or spoofed, the OS fingerprint leaks through the network stack â€” it's much harder to fake than a text banner.

### ğŸ”¬ Why Fingerprinting Works â€” The TCP/IP Stack Secret

Each OS has its own default values and behaviors baked into its network stack at the kernel level:

| OS | Default TTL | TCP Window Size | Key Behavior |
|----|:-----------:|:---------------:|-------------|
| **Windows 10/11** | 128 | 64,240 | Responds to broadcast ICMP differently |
| **Windows Server** | 128 | 65,535 | |
| **Linux (modern)** | 64 | 29,200 | |
| **macOS / iOS** | 64 | 65,535 | BSD-derived stack |
| **FreeBSD** | 64 | 65,535 | |
| **Solaris** | 255 | 8,760 | High TTL is a giveaway |
| **Cisco IOS** | 255 | 4,128 | Network device signature |

> âš ï¸ **TTL decrements by 1 at each router hop.** If you receive a packet with TTL=55 and the subnet is 9 hops away, the original TTL was 64 â†’ Linux/macOS.

---

### ğŸ”¹ Active Fingerprinting

The attacker sends **specially crafted probe packets** and analyzes how the target responds. Direct, accurate, but detectable.

#### âš™ï¸ Process

```
Step 1:  Send crafted probe packets (unusual flags, fragmentation, etc.)
              â†“
Step 2:  Capture and record the target's responses
              â†“
Step 3:  Compare response patterns against fingerprint database
              â†“
Step 4:  Predict OS with confidence percentage
```

#### ğŸ› ï¸ Nmap Active OS Detection

```bash
sudo nmap -O <target>
```

Aggressive (most accurate):
```bash
sudo nmap -O --osscan-guess <target>
```

Force OS detection even with limited data:
```bash
sudo nmap -O --osscan-limit <target>
```

#### Example Nmap OS Output

```
OS details: Linux 4.15 - 5.6
Network Distance: 1 hop
OS CPE: cpe:/o:linux:linux_kernel:4.15

OS details: Microsoft Windows 10 1903 - 21H1
OS CPE: cpe:/o:microsoft:windows_10
```

#### ğŸ“Š Active Fingerprinting â€” Pros & Cons

| Advantages | Disadvantages |
|------------|---------------|
| Highly accurate | Generates detectable traffic |
| Works even when banners are disabled | May be blocked by firewalls |
| Widely supported by tools | Can trigger IDS/IPS alerts |
| Fast results | Requires at least one open and one closed port |

---

### ğŸ”¹ Passive Fingerprinting

Instead of sending probes, the attacker **silently sniffs existing network traffic** and analyzes packet headers â€” no packets are sent to the target.

#### âš™ï¸ Process

```
Step 1:  Position sniffer to capture traffic (MITM, tap, monitor port)
              â†“
Step 2:  Observe TCP/IP headers in real traffic (TTL, window size, flags)
              â†“
Step 3:  Compare observed patterns against fingerprint database
              â†“
Step 4:  Infer OS without ever sending a packet to the target
```

#### ğŸ› ï¸ p0f â€” The Passive OS Fingerprinting Tool

```bash
# Start passive sniffing on interface
p0f -i eth0

# Read from a pcap file
p0f -r capture.pcap

# Output to log file
p0f -i eth0 -o /tmp/p0f.log
```

#### ğŸ“Š Passive Fingerprinting â€” Pros & Cons

| Advantages | Disadvantages |
|------------|---------------|
| âœ… Completely stealthy â€” zero packets sent | Requires packet capture access |
| âœ… Cannot be detected by the target | Slower â€” waits for natural traffic |
| âœ… No IDS alerts triggered | Less reliable with small traffic samples |
| âœ… Ideal for long-term monitoring | Limited by traffic visibility |

---

## 7. TCP/IP Stack Indicators â€” What Tools Analyze

OS fingerprinting tools examine multiple TCP/IP header fields simultaneously to build a composite fingerprint:

| Indicator | What It Reveals | Example |
|-----------|----------------|---------|
| **Initial TTL** | Starting TTL before decrements â€” OS-specific default | 64 = Linux/Mac; 128 = Windows |
| **TCP Window Size** | Default receive buffer â€” OS-defined | 65,535 vs 29,200 |
| **Don't Fragment (DF) Bit** | Whether OS sets DF in IP header | Most modern OS set DF=1 |
| **IP ID Sequence** | How IP identification field increments | Predictable in older Windows |
| **TCP Options** | Which options and in what order | SACK, timestamps, window scale |
| **SYN Packet Size** | Size of initial SYN â€” varies by OS | 44 bytes (Linux) vs 48 bytes (Windows) |
| **TCP Flags on Unusual Packets** | How OS handles weird flag combos | RST behavior on FIN/NULL/Xmas |
| **ICMP Error Message Quoting** | How much of original packet is echoed | OS-specific ICMP implementations |
| **Response Timing** | Retransmission intervals | OS scheduler behavior |

> ğŸ’¡ No single indicator definitively identifies an OS â€” tools combine **all of these** to produce a confidence-scored fingerprint match.

---

## 8. Common OS TTL & Window Size Signatures

This table is **high-yield for CEH** â€” questions often give you a TTL or window size and ask you to identify the OS.

| Operating System | Default TTL | TCP Window Size |
|-----------------|:-----------:|:---------------:|
| **Windows 10 / 11** | 128 | 64,240 |
| **Windows Server 2016/2019** | 128 | 65,535 |
| **Windows XP** | 128 | 65,535 |
| **Linux (kernel 4.x+)** | 64 | 29,200 |
| **Linux (older kernels)** | 64 | 5,840 |
| **macOS (Monterey+)** | 64 | 65,535 |
| **FreeBSD / OpenBSD** | 64 | 65,535 |
| **Solaris** | 255 | 8,760 |
| **Cisco IOS** | 255 | 4,128 |
| **Android** | 64 | 65,535 |

> ğŸ¯ **Quick Exam Rule:**
> - **TTL â‰ˆ 128** â†’ Windows
> - **TTL â‰ˆ 64** â†’ Linux / macOS / Android
> - **TTL â‰ˆ 255** â†’ Network devices (Cisco, Solaris)

---

## 9. Nmap OS Detection Workflow

### Basic OS Detection

```bash
sudo nmap -O <target>
```

> âš ï¸ Requires root/administrator privileges for raw packet access.

### Aggressive Mode â€” Most Accurate

```bash
sudo nmap -A <target>
```

Combines: OS detection (`-O`) + version detection (`-sV`) + NSE scripts (`-sC`) + traceroute.

### Guess When Confidence Is Low

```bash
sudo nmap -O --osscan-guess <target>
```

Forces Nmap to guess even when the fingerprint is ambiguous.

### OS Detection + Service Versions

```bash
sudo nmap -O -sV <target>
```

### Full Workflow Example

```bash
# Step 1: Quick host discovery
nmap -sn 10.10.1.0/24

# Step 2: SYN scan + OS detection on live hosts
sudo nmap -sS -O 10.10.1.5

# Step 3: Aggressive full recon
sudo nmap -A -T4 10.10.1.5

# Step 4: Save results
sudo nmap -A -oN os_results.txt 10.10.1.5
```

### ğŸ“Š Example Nmap OS Detection Output

```
Nmap scan report for 10.10.1.5
PORT     STATE SERVICE
22/tcp   open  ssh
80/tcp   open  http
443/tcp  open  https

Device type: general purpose
Running: Linux 4.X|5.X
OS CPE: cpe:/o:linux:linux_kernel:4  cpe:/o:linux:linux_kernel:5
OS details: Linux 4.15 - 5.6
Network Distance: 1 hop

OS detection performed. Please report incorrect results at https://nmap.org/submit/
```

---

## 10. Factors Affecting OS Detection Accuracy

| Factor | Impact on Accuracy |
|--------|:-----------------:|
| **Firewall filtering probe packets** | ğŸ”´ Major â€” filtered responses confuse the fingerprint engine |
| **Too few open/closed ports** | ğŸ”´ Major â€” Nmap needs both to compare response patterns |
| **High network latency** | ğŸŸ¡ Moderate â€” timing-based indicators become unreliable |
| **IDS/IPS interference** | ğŸŸ¡ Moderate â€” may drop or modify probe packets silently |
| **Packet loss on the link** | ğŸŸ¡ Moderate â€” incomplete response sets reduce confidence |
| **Load balancer / NAT** | ğŸŸ¡ Moderate â€” may translate or modify TCP headers |
| **Banner obfuscation** | ğŸŸ¢ Minor for fingerprinting â€” banners not used in stack analysis |
| **VPN / tunneling** | ğŸŸ¡ Moderate â€” encapsulation alters packet characteristics |

> ğŸ“Œ **CEH Key Fact:** Nmap's OS detection achieves best results when it has access to **at least one open port AND one closed port** on the target. This allows it to compare both connection and rejection responses.

---

## 11. OS Discovery Tools

| Tool | Type | Method | Key Strength | Source |
|------|:----:|:------:|-------------|--------|
| **Nmap** | CLI | Active | Most widely used; full TCP/IP stack fingerprinting | [https://nmap.org](https://nmap.org) |
| **p0f** | CLI | Passive | Pure passive sniffer â€” zero traffic sent to target | [https://lcamtuf.coredump.cx/p0f3](https://lcamtuf.coredump.cx/p0f3) |
| **Xprobe2** | CLI | Active | ICMP-based active fingerprinting; alternative to Nmap | [https://github.com/muayyad-alsadi/xprobe2](https://github.com/muayyad-alsadi/xprobe2) |
| **Hping3** | CLI | Active | Manual crafted probes for advanced fingerprinting | [https://salsa.debian.org/debian/hping3](https://salsa.debian.org/debian/hping3) |
| **Metasploit** | Framework | Active | `auxiliary/scanner/smb/smb_version` and similar modules | [https://www.metasploit.com](https://www.metasploit.com) |
| **Wireshark** | GUI Sniffer | Passive | Captures and displays packet-level OS indicators | [https://www.wireshark.org](https://www.wireshark.org) |

### ğŸ”¥ p0f â€” Passive Fingerprinting Deep Dive

**p0f** is the go-to tool for **completely stealthy** OS identification. It identifies operating systems, network topology, and link types entirely from captured packets.

```bash
# Install (Debian/Ubuntu)
sudo apt install p0f

# Run on live interface
sudo p0f -i eth0 -p

# Analyze saved capture
sudo p0f -r capture.pcap

# Run in daemon mode with API
sudo p0f -i eth0 -d -s /tmp/p0f.sock
```

Sample p0f output:
```
.-[ 10.10.1.5/80 -> 10.10.1.1/54321 (syn) ]-
|
| client   = 10.10.1.5
| os       = Linux 3.11 and newer
| dist     = 0
| params   = none
| raw_sig  = 4:64+0:0:1452:29200,10:mss,sok,ts,nop,ws:df,id+:0
`----
```

---

## 12. Banner Grabbing vs. OS Fingerprinting â€” Comparison

| Feature | Banner Grabbing | Active Fingerprinting | Passive Fingerprinting |
|---------|:--------------:|:--------------------:|:---------------------:|
| **Method** | Reads service text | Sends crafted probes | Sniffs existing traffic |
| **Accuracy** | ğŸŸ¡ Medium | ğŸŸ¢ High | ğŸŸ¢ High |
| **Stealth** | ğŸŸ¡ Moderate | ğŸ”´ Low | ğŸŸ¢ Very High |
| **Can be spoofed/disabled** | âœ… Yes (easily) | âŒ Harder | âŒ Harder |
| **Requires open port** | âœ… Yes | âœ… Usually | âŒ No â€” just traffic |
| **Detectable by IDS** | ğŸŸ¡ Sometimes | âœ… Yes | âŒ Never |
| **Privileges needed** | âŒ None | âœ… Root/Admin | âœ… Packet capture |
| **Primary tool** | nc, telnet, curl | Nmap (`-O`) | p0f |
| **Best used when** | Quick initial recon | Accurate OS needed | Stealth is critical |

---

## 13. CEH Exam Traps & Tips

| âš ï¸ Exam Trap | âœ… Correct Understanding |
|-------------|------------------------|
| **Banner grabbing = OS fingerprinting** | âŒ Different techniques â€” banners are text; fingerprinting is TCP/IP stack analysis |
| **Passive fingerprinting is less accurate** | âš ï¸ It can be equally accurate but requires sufficient traffic samples |
| **Active fingerprinting is always stealthy** | âŒ False â€” active sends packets and is detectable |
| **Spoofed banners fool OS fingerprinting** | âŒ False â€” fingerprinting doesn't rely on banners |
| **Nmap OS detection needs no privileges** | âŒ False â€” requires root/admin for raw packet crafting |
| **TTL 64 = Windows** | âŒ False â€” TTL 64 = Linux/macOS; TTL 128 = Windows |
| **Version detection `-sV` = OS detection** | âŒ Different â€” `-sV` finds service versions; `-O` fingerprints the OS |
| **Firewalls don't affect OS detection** | âŒ False â€” packet filtering significantly reduces fingerprint accuracy |
| **p0f is an active scanner** | âŒ False â€” p0f is purely **passive**; it never sends packets |
| **OS detection works without any open port** | âš ï¸ Partially â€” Nmap needs at least one open AND one closed port for best accuracy |

---

### ğŸ“‹ Quick Command Reference Card

| Goal | Command |
|------|---------|
| Banner grab via Netcat | `nc -nv <target> <port>` |
| Banner grab via curl | `curl -I http://<target>` |
| Nmap version detection | `nmap -sV <target>` |
| Nmap basic OS detection | `sudo nmap -O <target>` |
| Nmap aggressive OS + version | `sudo nmap -A <target>` |
| Nmap OS with guess fallback | `sudo nmap -O --osscan-guess <target>` |
| Passive OS fingerprinting | `sudo p0f -i eth0` |
| p0f from pcap file | `sudo p0f -r capture.pcap` |
| Hping3 probe for fingerprint | `hping3 -S <target> -p 80` |
| OS + version combined | `sudo nmap -O -sV <target>` |

---

*ğŸ“š CEH v13 Â· Module 03: Scanning Networks | Last updated: February 2026*