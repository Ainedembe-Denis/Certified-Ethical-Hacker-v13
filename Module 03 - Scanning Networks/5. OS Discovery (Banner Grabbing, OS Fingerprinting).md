# ğŸ–¥ï¸ OS Discovery â€” Banner Grabbing & OS Fingerprinting
### CEH v13 Â· Module 03: Scanning Networks

> **About these notes:** A practical, exam-ready reference on OS discovery â€” covering banner grabbing mechanics, active vs. passive fingerprinting, TCP/IP stack analysis, tools (Wireshark, Nmap, Unicornscan, NSE, AI), and CEH exam traps.

---

## ğŸ“‘ Table of Contents

1. [What is OS Discovery?](#1-what-is-os-discovery)
2. [Where It Fits in the Scanning Workflow](#2-where-it-fits-in-the-scanning-workflow)
3. [Why OS Discovery Matters](#3-why-os-discovery-matters)
4. [Two Primary Methods Overview](#4-two-primary-methods-overview)
5. [Banner Grabbing](#5-banner-grabbing)
   - [How It Works](#ï¸-how-banner-grabbing-works)
   - [Tools & Commands](#ï¸-banner-grabbing-tools--commands)
   - [Advantages & Limitations](#-advantages--limitations)
6. [OS Fingerprinting](#6-os-fingerprinting)
   - [How Fingerprinting Works](#-why-fingerprinting-works--the-tcpip-stack-secret)
   - [Active Fingerprinting](#-active-fingerprinting)
   - [Passive Fingerprinting](#-passive-fingerprinting)
7. [TCP/IP Stack Indicators â€” What Tools Analyze](#7-tcpip-stack-indicators--what-tools-analyze)
8. [Common OS TTL & Window Size Signatures](#8-common-os-ttl--window-size-signatures)
9. [Nmap OS Detection Workflow](#9-nmap-os-detection-workflow)
10. [Factors Affecting OS Detection Accuracy](#10-factors-affecting-os-detection-accuracy)
11. [OS Discovery Tools â€” Extended Coverage](#11-os-discovery-tools--extended-coverage)
    - [Wireshark â€” Passive OS Fingerprinting](#-tool-1-wireshark--passive-os-fingerprinting)
    - [Nmap â€” Active OS Fingerprinting](#-tool-2-nmap--active-os-fingerprinting)
    - [Unicornscan â€” High-Speed OS Discovery](#-tool-3-unicornscan--high-speed-os-discovery)
    - [Nmap NSE â€” Script-Based OS Analysis](#-tool-4-nmap-nse--script-based-os-analysis)
    - [AI-Assisted OS Discovery](#-tool-5-ai-assisted-os-discovery)
12. [Banner Grabbing vs. OS Fingerprinting â€” Comparison](#12-banner-grabbing-vs-os-fingerprinting--comparison)
13. [Master OS Discovery Tools Comparison](#13-master-os-discovery-tools-comparison)
14. [CEH Exam Traps & Tips](#14-ceh-exam-traps--tips)
15. [Mnemonics & Quick Recall](#15-mnemonics--quick-recall)

---

## 1. What is OS Discovery?

**OS Discovery** is the process of identifying the **operating system, version, and system architecture** running on a target machine â€” also known in CEH terminology as **fingerprinting**.

Attackers perform OS discovery **after port and service discovery** to select the right OS-specific exploits and tailor their attack strategy for precision. Without knowing the target OS, an attacker would be guessing â€” potentially deploying the wrong exploits, triggering more noise, and alerting defenders.

> ğŸ§  **Mental Model â€” The Scanning Chain:**
> ```
> Host Discovery   â†’ "Who is alive?"
> Port Discovery   â†’ "What doors are open?"
> OS Discovery     â†’ "What exact system am I attacking?"
> ```

---

## 2. Where It Fits in the Scanning Workflow

```
Footprinting (Passive Recon)
         â†“
Host Discovery
         â†“
Port & Service Discovery
         â†“
OS Discovery     â† â˜… YOU ARE HERE
         â†“
Vulnerability Analysis
         â†“
Exploitation
```

> ğŸ“Œ **CEH Sequence Rule:** OS discovery always comes **after** port scanning. Without open/closed ports, OS fingerprinting has nothing to analyze.

---

## 3. Why OS Discovery Matters

Different operating systems have fundamentally different vulnerabilities, patch cycles, and exploitation paths. Knowing the OS lets the attacker operate with precision.

| Attacker Goal | How OS Knowledge Helps |
|--------------|------------------------|
| **Choose the right exploit** | CVEs and exploits are OS and version specific |
| **Identify OS-specific vulnerabilities** | Windows â†’ SMB; Linux â†’ sudo misconfigs, etc. |
| **Tailor attack strategies** | Different post-exploitation tools per OS |
| **Increase attack success rate** | Avoids running incompatible exploits |
| **Reduce noise** | Fewer failed attempts = less IDS alerting |

> ğŸ’¡ **Real-World Example:** Detecting Windows XP SP3 â†’ immediate EternalBlue candidate. Detecting Ubuntu 20.04 â†’ check sudo CVEs, dirty pipe, polkit. The OS shapes the **entire** attack path.

---

## 4. Two Primary Methods Overview

| Method | How It Works | Stealth | Accuracy |
|--------|-------------|:-------:|:--------:|
| **Banner Grabbing** | Reads the text banner a service announces upon connection | ğŸŸ¡ Moderate | ğŸŸ¡ Medium |
| **OS Fingerprinting** | Analyzes TCP/IP stack behavior â€” no banner needed | ğŸŸ¢ High (passive) | ğŸŸ¢ High |

> ğŸ’¡ Fingerprinting is more reliable because banners can be **disabled or spoofed**. TCP/IP stack behavior cannot easily be faked.

---

## 5. Banner Grabbing

### ğŸ“Œ What Is It?

**Banner grabbing** extracts service and system information by reading the **banner** â€” the identifying text a network service sends automatically when a client connects.

Many services are configured to announce themselves, often revealing far more than intended. For example, an FTP server might greet you with its software name and version number before you've even authenticated â€” this is valuable intelligence for an attacker.

### âš™ï¸ How Banner Grabbing Works

```
Step 1:  Attacker connects to an open port (e.g., port 80, 22, 21, 25)
              â†“
Step 2:  Service automatically sends its banner upon connection
              â†“
Step 3:  Attacker reads and analyzes the banner text
              â†“
Step 4:  Extracts:
          â”œâ”€â”€ Application name  (Apache, OpenSSH, Postfix, IIS...)
          â”œâ”€â”€ Version number    (2.4.49, 8.2p1, 3.5...)
          â””â”€â”€ Underlying OS     (Ubuntu, Debian, Windows Server...)
```

### ğŸ“Š Example Banners and What They Reveal

| Banner Received | Information Extracted |
|----------------|-----------------------|
| `Apache/2.4.49 (Ubuntu)` | Apache web server, version 2.4.49, running on Ubuntu |
| `OpenSSH_8.2p1 Ubuntu-4ubuntu0.5` | OpenSSH 8.2 on Ubuntu â€” check for CVE-2021-28041 |
| `220 mail.example.com ESMTP Postfix` | Postfix mail server â€” may reveal hostname |
| `Microsoft-IIS/10.0` | IIS 10.0 â†’ Windows Server 2016/2019 |
| `SSH-2.0-OpenSSH_7.4` | Old OpenSSH â€” CVE-2018-15473 username enumeration |

### ğŸ› ï¸ Banner Grabbing Tools & Commands

#### ğŸ”¹ Netcat (nc) â€” The Swiss Army Knife

```bash
# Connect to HTTP port and read banner
nc -nv <target> 80
HEAD / HTTP/1.0     # then press Enter twice

# Connect to FTP server
nc -nv <target> 21

# Connect to SMTP
nc -nv <target> 25
```

#### ğŸ”¹ Telnet â€” Classic Method

```bash
telnet <target> 80
telnet <target> 22
telnet <target> 25
```

#### ğŸ”¹ Nmap Service Version Detection â€” Automated Banner Grabbing

```bash
nmap -sV <target>
```

Increase probe intensity for more aggressive banner extraction:
```bash
nmap -sV --version-intensity 9 <target>
```

#### ğŸ”¹ curl â€” HTTP Banner & Header Extraction

```bash
# Grab HTTP response headers
curl -I http://<target>

# Show verbose with full server response
curl -v http://<target>
```

#### ğŸ”¹ Wget â€” Alternative HTTP Banner Grab

```bash
wget --server-response -q --spider http://<target>
```

#### ğŸ”¹ Python â€” Programmatic Banner Grabbing

```python
import socket

target = "10.10.1.11"
port = 80

s = socket.socket()
s.connect((target, port))
s.send(b"HEAD / HTTP/1.0\r\n\r\n")
banner = s.recv(1024)
print(banner.decode())
s.close()
```

### âœ… Advantages & Limitations

| Advantages | Limitations |
|------------|-------------|
| Simple â€” requires no special tools | Banners can be **disabled** by admins |
| Fast â€” immediate results on connection | Banners can be **spoofed** to mislead |
| Low traffic â€” minimal footprint | Not all services reveal the OS |
| Works with any service that sends text | May be **blocked** by WAF or firewall |
| Requires no root privileges | Version info may be **falsified** |

> ğŸ¯ **CEH Examiner Tip:** Banner grabbing is **not always reliable** â€” this exact statement appears in exam questions. Spoofed banners are a common defensive countermeasure.

---

## 6. OS Fingerprinting

### ğŸ“Œ What Is It?

**OS fingerprinting** identifies the operating system by analyzing **TCP/IP stack behavior** â€” not banners. Every OS implements the TCP/IP protocol suite slightly differently, creating a unique "fingerprint."

Think of it like identifying a person's nationality from their accent and mannerisms, even if they refuse to show you their passport. The OS "accent" is baked into every packet it sends.

> ğŸ’¡ Even if banners are disabled or spoofed, the OS fingerprint leaks through the network stack â€” it's much harder to fake than a text banner.

### ğŸ”¬ Why Fingerprinting Works â€” The TCP/IP Stack Secret

Each OS has its own default values and behaviors baked into its network stack at the kernel level. These include TTL values, TCP window sizes, and option ordering â€” all of which vary predictably per OS.

> ğŸ“Œ See [Section 8](#8-common-os-ttl--window-size-signatures) for the full OS signature table with TTL and TCP Window Size values.

> âš ï¸ **TTL decrements by 1 at each router hop.** If you receive a packet with TTL=55 and the subnet is 9 hops away, the original TTL was 64 â†’ Linux/macOS.

---

### ğŸ”¹ Active Fingerprinting

The attacker sends **specially crafted probe packets** and analyzes how the target responds. Direct, accurate, but detectable.

#### âš™ï¸ Process

```
Step 1:  Send crafted probe packets (unusual flags, fragmentation, etc.)
              â†“
Step 2:  Capture and record the target's responses
              â†“
Step 3:  Compare response patterns against fingerprint database
              â†“
Step 4:  Predict OS with confidence percentage
```

#### ğŸ› ï¸ Primary Tool â€” Nmap

> ğŸ“Œ Full Nmap commands and workflow are in [Section 9](#9-nmap-os-detection-workflow). For the lab-documented CEH output and detailed breakdown, see [Tool 2 in Section 11](#-tool-2-nmap--active-os-fingerprinting).

#### ğŸ“Š Active Fingerprinting â€” Pros & Cons

| Advantages | Disadvantages |
|------------|---------------|
| Highly accurate | Generates detectable traffic |
| Works even when banners are disabled | May be blocked by firewalls |
| Widely supported by tools | Can trigger IDS/IPS alerts |
| Fast results | Requires at least one open and one closed port |

---

### ğŸ”¹ Passive Fingerprinting

Instead of sending probes, the attacker **silently sniffs existing network traffic** and analyzes packet headers â€” no packets are sent to the target.

#### âš™ï¸ Process

```
Step 1:  Position sniffer to capture traffic (MITM, tap, monitor port)
              â†“
Step 2:  Observe TCP/IP headers in real traffic (TTL, window size, flags)
              â†“
Step 3:  Compare observed patterns against fingerprint database
              â†“
Step 4:  Infer OS without ever sending a packet to the target
```

#### ğŸ› ï¸ p0f â€” The Passive OS Fingerprinting Tool

```bash
# Start passive sniffing on interface
p0f -i eth0

# Read from a pcap file
p0f -r capture.pcap

# Output to log file
p0f -i eth0 -o /tmp/p0f.log
```

#### ğŸ“Š Passive Fingerprinting â€” Pros & Cons

| Advantages | Disadvantages |
|------------|---------------|
| âœ… Completely stealthy â€” zero packets sent | Requires packet capture access |
| âœ… Cannot be detected by the target | Slower â€” waits for natural traffic |
| âœ… No IDS alerts triggered | Less reliable with small traffic samples |
| âœ… Ideal for long-term monitoring | Limited by traffic visibility |

---

## 7. TCP/IP Stack Indicators â€” What Tools Analyze

OS fingerprinting tools examine multiple TCP/IP header fields simultaneously to build a composite fingerprint:

| Indicator | What It Reveals | Example |
|-----------|----------------|---------|
| **Initial TTL** | Starting TTL before decrements â€” OS-specific default | 64 = Linux/Mac; 128 = Windows |
| **TCP Window Size** | Default receive buffer â€” OS-defined | 65,535 vs 29,200 |
| **Don't Fragment (DF) Bit** | Whether OS sets DF in IP header | Most modern OS set DF=1 |
| **IP ID Sequence** | How IP identification field increments | Predictable in older Windows |
| **TCP Options** | Which options and in what order | SACK, timestamps, window scale |
| **SYN Packet Size** | Size of initial SYN â€” varies by OS | 44 bytes (Linux) vs 48 bytes (Windows) |
| **TCP Flags on Unusual Packets** | How OS handles weird flag combos | RST behavior on FIN/NULL/Xmas |
| **ICMP Error Message Quoting** | How much of original packet is echoed | OS-specific ICMP implementations |
| **Response Timing** | Retransmission intervals | OS scheduler behavior |

> ğŸ’¡ No single indicator definitively identifies an OS â€” tools combine **all of these** to produce a confidence-scored fingerprint match.

---

## 8. Common OS TTL & Window Size Signatures

This table is **high-yield for CEH** â€” questions often give you a TTL or window size and ask you to identify the OS.

| Operating System | Default TTL | TCP Window Size |
|-----------------|:-----------:|:---------------:|
| **Windows 10 / 11** | 128 | 64,240 |
| **Windows Server 2016/2019** | 128 | 65,535 |
| **Windows XP** | 128 | 65,535 |
| **Linux (kernel 4.x+)** | 64 | 29,200 |
| **Linux (older kernels)** | 64 | 5,840 |
| **macOS (Monterey+)** | 64 | 65,535 |
| **FreeBSD / OpenBSD** | 64 | 65,535 |
| **Solaris** | 255 | 8,760 |
| **Cisco IOS** | 255 | 4,128 |
| **Android** | 64 | 65,535 |

> ğŸ¯ **Quick Exam Rule:**
> - **TTL â‰ˆ 128** â†’ Windows
> - **TTL â‰ˆ 64** â†’ Linux / macOS / Android
> - **TTL â‰ˆ 255** â†’ Network devices (Cisco, Solaris)

---

## 9. Nmap OS Detection Workflow

### Basic OS Detection

```bash
sudo nmap -O <target>
```

> âš ï¸ Requires root/administrator privileges for raw packet access.

### Aggressive Mode â€” Most Accurate

```bash
sudo nmap -A <target>
```

Combines: OS detection (`-O`) + version detection (`-sV`) + NSE scripts (`-sC`) + traceroute.

### Guess When Confidence Is Low

```bash
sudo nmap -O --osscan-guess <target>
```

Forces Nmap to guess even when the fingerprint is ambiguous.

### OS Detection + Service Versions

```bash
sudo nmap -O -sV <target>
```

### Full Workflow Example

```bash
# Step 1: Quick host discovery
nmap -sn 10.10.1.0/24

# Step 2: SYN scan + OS detection on live hosts
sudo nmap -sS -O 10.10.1.5

# Step 3: Aggressive full recon
sudo nmap -A -T4 10.10.1.5

# Step 4: Save results
sudo nmap -A -oN os_results.txt 10.10.1.5
```

### ğŸ“Š Example Nmap OS Detection Output

```
Nmap scan report for 10.10.1.5
PORT     STATE SERVICE
22/tcp   open  ssh
80/tcp   open  http
443/tcp  open  https

Device type: general purpose
Running: Linux 4.X|5.X
OS CPE: cpe:/o:linux:linux_kernel:4  cpe:/o:linux:linux_kernel:5
OS details: Linux 4.15 - 5.6
Network Distance: 1 hop

OS detection performed. Please report incorrect results at https://nmap.org/submit/
```

---

## 10. Factors Affecting OS Detection Accuracy

| Factor | Impact on Accuracy |
|--------|:-----------------:|
| **Firewall filtering probe packets** | ğŸ”´ Major â€” filtered responses confuse the fingerprint engine |
| **Too few open/closed ports** | ğŸ”´ Major â€” Nmap needs both to compare response patterns |
| **High network latency** | ğŸŸ¡ Moderate â€” timing-based indicators become unreliable |
| **IDS/IPS interference** | ğŸŸ¡ Moderate â€” may drop or modify probe packets silently |
| **Packet loss on the link** | ğŸŸ¡ Moderate â€” incomplete response sets reduce confidence |
| **Load balancer / NAT** | ğŸŸ¡ Moderate â€” may translate or modify TCP headers |
| **Banner obfuscation** | ğŸŸ¢ Minor for fingerprinting â€” banners not used in stack analysis |
| **VPN / tunneling** | ğŸŸ¡ Moderate â€” encapsulation alters packet characteristics |

> ğŸ“Œ **CEH Key Fact:** Nmap's OS detection achieves best results when it has access to **at least one open port AND one closed port** on the target. This allows it to compare both connection and rejection responses.

---

## 11. OS Discovery Tools â€” Extended Coverage

This section covers all five documented OS discovery techniques in detail, as referenced in CEH Module 03 lab materials.

---

### ğŸ”µ Tool 1: Wireshark â€” Passive OS Fingerprinting

**Source:** [https://www.wireshark.org](https://www.wireshark.org)  
**Type:** Passive (no probes sent)

#### What It Is

Wireshark is a powerful GUI-based network protocol analyzer used to **capture and inspect packets** in real time. For OS discovery, it is used to passively fingerprint the operating system of any host generating traffic on the network â€” without ever sending a packet to the target.

This makes Wireshark a **stealth-first** OS discovery method, ideal for scenarios where you want to remain undetected.

#### Key OS Indicators Analyzed in Wireshark

| Indicator | What to Look For | OS Inference |
|-----------|-----------------|--------------|
| **TTL Value** | IP header TTL in any captured packet | TTL 128 â†’ Windows; TTL 64 â†’ Linux/macOS |
| **TCP Window Size** | SYN or SYN-ACK packets | 64,240 â†’ Windows 10; 29,200 â†’ Linux |
| **TCP Options** | Options in SYN packets (MSS, SACK, WScale) | Order and combination are OS-specific |
| **ICMP Error Codes** | Responses to ICMP probes | Different OSes return different ICMP payloads |
| **IP ID Sequence** | ID field increments across packets | Predictable (older Windows) vs random (Linux) |

#### How to Use Wireshark for OS Discovery

```
1. Launch Wireshark and select the network interface (e.g., eth0)
2. Start capture: Capture â†’ Start
3. Apply a display filter to isolate the target host:
       ip.addr == 10.10.1.11
4. Look for SYN or ICMP packets from the target
5. Inspect the IP TTL and TCP Window Size fields in the packet details pane
6. Cross-reference values against the OS signature table
```

#### Display Filter Examples

```wireshark
# Filter traffic to/from a specific host
ip.addr == 10.10.1.11

# Show only TCP SYN packets (initial handshake)
tcp.flags.syn == 1 && tcp.flags.ack == 0

# Show only ICMP traffic
icmp

# Show TTL values in results column â€” add TTL as a column via:
# View â†’ Column Preferences â†’ Add â†’ IP TTL
```

#### Strengths & Limitations

| Strengths | Limitations |
|-----------|-------------|
| âœ… Completely passive â€” no packets sent to target | Requires existing traffic from the target |
| âœ… Stealthy â€” IDS cannot detect it | Cannot initiate discovery on its own |
| âœ… Deep packet visibility | Requires physical/network access to capture |
| âœ… GUI-friendly for beginners | Less automated than Nmap or p0f |
| âœ… Can analyze historical pcap files | Analyst must manually interpret indicators |

> ğŸ’¡ **When to Use Wireshark:** Best in environments where you are already monitoring network traffic (e.g., inside a network segment) and want to silently profile which OS each host is likely running without triggering any alerts.

---

### ğŸŸ¢ Tool 2: Nmap â€” Active OS Fingerprinting

**Source:** [https://nmap.org](https://nmap.org) | Zenmap GUI also available  
**Type:** Active  
**Primary Command:** `nmap -O <target>`

#### What It Is

Nmap (Network Mapper) is the industry-standard OS fingerprinting tool. It performs **active fingerprinting** by sending a series of crafted TCP, UDP, and ICMP probe packets to the target and comparing the responses against its massive OS signature database â€” one of the largest available.

> ğŸ“Œ Full command reference and workflow examples are in [Section 9](#9-nmap-os-detection-workflow). The key commands are: `sudo nmap -O <target>` (basic), `sudo nmap -A <target>` (aggressive), `sudo nmap -O --osscan-guess <target>` (low-confidence guess).

#### Documented Lab Output (CEH Module 03)

```
Nmap scan report for 10.10.1.11
Host is up (0.00072s latency).
Not shown: 997 closed ports
PORT    STATE SERVICE
135/tcp open  msrpc
139/tcp open  netbios-ssn
445/tcp open  microsoft-ds

Device type: general purpose
Running: Microsoft Windows 7|10
OS CPE: cpe:/o:microsoft:windows_7  cpe:/o:microsoft:windows_10
OS details: Microsoft Windows 7 - 10
Network Distance: 1 hop
```

#### What It Reports

| Output Field | Meaning |
|-------------|---------|
| `Device type` | Category: general purpose, printer, router, etc. |
| `Running` | Detected OS family and version range |
| `OS CPE` | Common Platform Enumeration â€” standardized OS identifier |
| `OS details` | Best match from fingerprint database |
| `Network Distance` | Number of hops to target |

#### Strengths & Limitations

| Strengths | Limitations |
|-----------|-------------|
| âœ… Most widely used OS detection tool | Active â€” detectable by IDS/IPS |
| âœ… Largest OS fingerprint database | Requires raw socket access (root/admin) |
| âœ… Accurate across thousands of OS variants | Accuracy drops behind firewalls or NAT |
| âœ… Free, cross-platform | Needs at least 1 open + 1 closed port |

---

### ğŸŸ  Tool 3: Unicornscan â€” High-Speed OS Discovery

**Source:** [https://sourceforge.net/projects/unicornscan](https://sourceforge.net/projects/unicornscan)  
**Type:** Active  
**Key Trait:** Asynchronous, high-performance scanning

#### What It Is

**Unicornscan** is an asynchronous TCP/IP scanner designed for high-speed network discovery and OS fingerprinting at scale. Unlike Nmap which uses a synchronous send-receive cycle, Unicornscan separates the packet-sending and packet-receiving phases, allowing it to scan large networks dramatically faster.

It is particularly useful in **large enterprise environments** or during **Red Team engagements** where scanning thousands of hosts quickly is a priority.

#### How It Works

```
Phase 1 (Send):    Sends crafted packets to all targets at high speed
Phase 2 (Receive): Asynchronously collects responses
Phase 3 (Analyze): Matches response patterns against OS signatures
```

> ğŸ’¡ Because the send and receive phases are decoupled, Unicornscan can maintain very high packet-per-second rates without waiting for responses before sending the next probe.

#### Key Commands

```bash
# Basic TCP scan with OS fingerprinting
unicornscan -mT <target>:1-1024

# Scan a full subnet
unicornscan -mT 10.10.1.0/24:80

# UDP scan
unicornscan -mU <target>:53

# Verbose output with timing stats
unicornscan -mT -Iv <target>:1-65535
```

#### Strengths & Limitations

| Strengths | Limitations |
|-----------|-------------|
| âœ… Extremely fast â€” ideal for large networks | Smaller OS signature database than Nmap |
| âœ… Asynchronous â€” doesn't wait between probes | Less intuitive output format |
| âœ… Good for scanning entire subnets quickly | Less community support and documentation |
| âœ… Useful for initial discovery before Nmap | May miss some OS variants |

> ğŸ“Œ **CEH Context:** Unicornscan is documented in CEH primarily for its **speed advantage** in large-scale OS discovery scenarios. For **accuracy**, Nmap remains the preferred tool.

---

### ğŸ”´ Tool 4: Nmap NSE â€” Script-Based OS Analysis

**Source:** [https://nmap.org/nsedoc](https://nmap.org/nsedoc)  
**Type:** Active  
**Method:** Nmap Scripting Engine (NSE) â€” Lua-based scripts for targeted service interrogation

#### What It Is

The **Nmap Scripting Engine (NSE)** extends Nmap's capabilities far beyond basic OS detection. NSE allows Nmap to run specialized Lua scripts against open services to extract deep OS and software information â€” including **Windows version, domain name, NetBIOS name, and OS build number** â€” that standard `-O` scanning cannot easily retrieve.

This is particularly powerful against **Windows targets** via protocols like SMB and RDP.

#### Key OS Discovery Scripts

##### SMB OS Discovery (Port 445)

```bash
nmap --script=smb-os-discovery -p 445 <target>
```

**What it extracts:**
- Windows OS name and version (e.g., Windows Server 2016 Standard 14393)
- Computer name (NetBIOS hostname)
- Domain name or workgroup
- Active Directory forest and domain
- System time

**Example Output:**

```
Host script results:
| smb-os-discovery:
|   OS: Windows Server 2016 Standard 14393 (Windows Server 2016 Standard 6.3)
|   OS CPE: cpe:/o:microsoft:windows_server_2016::-
|   Computer name: WIN-SERVER01
|   NetBIOS computer name: WIN-SERVER01\x00
|   Domain name: corp.example.local
|   Forest name: example.local
|   FQDN: WIN-SERVER01.corp.example.local
|_  System time: 2024-01-15T10:30:00+00:00
```

##### RDP NTLM Info (Port 3389)

```bash
nmap --script=rdp-ntlm-info -p 3389 <target>
```

**What it extracts:**
- Windows version via NTLM authentication negotiation
- DNS domain and computer names
- NetBIOS information
- OS build number

**Example Output:**

```
Host script results:
| rdp-ntlm-info:
|   Target_Name: CORP
|   NetBIOS_Domain_Name: CORP
|   NetBIOS_Computer_Name: WIN10-PC01
|   DNS_Domain_Name: corp.example.local
|   DNS_Computer_Name: WIN10-PC01.corp.example.local
|   Product_Version: 10.0.19041
|_  System_Time: 2024-01-15T10:30:00+00:00
```

> ğŸ’¡ `Product_Version: 10.0.19041` â†’ Windows 10 Build 19041 â†’ Windows 10 version 2004. Build numbers directly map to Windows versions.

##### Additional Useful NSE Scripts

```bash
# Enumerate SMB shares and users (can reveal OS context)
nmap --script=smb-enum-shares,smb-enum-users -p 445 <target>

# HTTP server header analysis
nmap --script=http-server-header -p 80,443 <target>

# SSH version and algorithms (can narrow down OS)
nmap --script=ssh2-enum-algos -p 22 <target>

# Combine multiple scripts
nmap --script=smb-os-discovery,rdp-ntlm-info -p 445,3389 <target>
```

#### Strengths & Limitations

| Strengths | Limitations |
|-----------|-------------|
| âœ… Returns highly specific OS details (version, build, domain) | Active â€” visible to IDS/IPS/SIEM |
| âœ… Extracts info that `-O` misses | Port must be open and accessible |
| âœ… Automates complex protocol interrogation | NSE library must be up to date |
| âœ… Can reveal AD domain structure | Some scripts may crash vulnerable services |

> ğŸ¯ **CEH Exam Note:** The `smb-os-discovery` and `rdp-ntlm-info` scripts are specifically documented in CEH Module 03. Know which port each uses: **SMB = 445, RDP = 3389**.

---

### ğŸ¤– Tool 5: AI-Assisted OS Discovery

**Type:** Hybrid (Active/Automated)  
**Key Concept:** Using AI/LLM chat interfaces to generate and execute scanning commands

#### What It Is

AI-assisted OS discovery represents an emerging threat vector where attackers leverage **AI language models** (like ChatGPT, ShellGPT, or similar tools) to automatically generate correct scanning commands, interpret results, and adapt their reconnaissance strategy â€” significantly lowering the skill barrier for attackers.

The CEH v13 curriculum acknowledges this development as part of its modern threat landscape coverage.

#### Documented CEH Example

The following demonstrates AI-generated command execution using **ShellGPT** (`sgpt`):

```bash
# Prompt ShellGPT to generate and execute an Hping3 ICMP scanning command
sgpt --chat scan --shell "Use Hping3 to perform ICMP scanning on the target IP address 10.10.1.11 and stop after 10 iterations"
```

**What happens:**
1. The AI receives the request in plain English
2. Generates the correct Hping3 command: `hping3 -1 10.10.1.11 --count 10`
3. Executes it directly in the shell
4. Analyzes the ICMP responses to infer OS characteristics from TTL values

**Equivalent manual command:**
```bash
hping3 -1 10.10.1.11 --count 10
```

> ğŸ’¡ **What Hping3 ICMP Reveals for OS Discovery:**
> Hping3 sends custom ICMP packets and the TTL in the response reveals the OS family. If TTL returns as ~128 â†’ Windows; ~64 â†’ Linux; ~255 â†’ Cisco/Solaris.

#### Why AI Matters in the Attack Context

| Aspect | Impact |
|--------|--------|
| **Lowers skill barrier** | Attackers without deep tool knowledge can craft complex commands via plain language |
| **Speeds up reconnaissance** | AI can chain multiple scanning steps automatically |
| **Adaptive** | AI can interpret partial results and suggest follow-up actions |
| **Hard to predict** | AI-generated attack paths may be unconventional and bypass signature-based defenses |

#### Ethical Hacker Implications

- Defenders must understand that **AI-driven automation** is now part of the attacker toolkit
- Threat models must account for **AI-generated reconnaissance** patterns
- Blue team detection rules should monitor for **rapid, sequential tool usage** that may indicate AI orchestration
- Penetration testers can use AI tools legitimately to improve efficiency in authorized engagements

#### Strengths & Limitations

| Strengths | Limitations |
|-----------|-------------|
| âœ… Eliminates command memorization | Requires AI tool setup (e.g., ShellGPT, API key) |
| âœ… Accelerates complex task execution | AI may generate incorrect commands for edge cases |
| âœ… Can explain and adapt based on results | Raises ethical and legal concerns if misused |
| âœ… Useful in CTF and authorized pen testing | AI output should always be reviewed before execution |

---

## 12. Banner Grabbing vs. OS Fingerprinting â€” Comparison

| Feature | Banner Grabbing | Active Fingerprinting | Passive Fingerprinting |
|---------|:--------------:|:--------------------:|:---------------------:|
| **Method** | Reads service text | Sends crafted probes | Sniffs existing traffic |
| **Accuracy** | ğŸŸ¡ Medium | ğŸŸ¢ High | ğŸŸ¢ High |
| **Stealth** | ğŸŸ¡ Moderate | ğŸ”´ Low | ğŸŸ¢ Very High |
| **Can be spoofed/disabled** | âœ… Yes (easily) | âŒ Harder | âŒ Harder |
| **Requires open port** | âœ… Yes | âœ… Usually | âŒ No â€” just traffic |
| **Detectable by IDS** | ğŸŸ¡ Sometimes | âœ… Yes | âŒ Never |
| **Privileges needed** | âŒ None | âœ… Root/Admin | âœ… Packet capture |
| **Primary tool** | nc, telnet, curl | Nmap (`-O`) | p0f, Wireshark |
| **Best used when** | Quick initial recon | Accurate OS needed | Stealth is critical |

---

## 13. Master OS Discovery Tools Comparison

| Tool | Method | Speed | Accuracy | Stealth | Best For |
|------|:------:|:-----:|:--------:|:-------:|---------|
| **Wireshark** | Passive | ğŸŸ¡ Slow (waits for traffic) | ğŸŸ¡ Medium | ğŸŸ¢ Very High | Silent OS profiling on live networks |
| **Nmap (-O)** | Active | ğŸŸ¢ Fast | ğŸŸ¢ High | ğŸ”´ Low | Standard OS fingerprinting |
| **Unicornscan** | Active | ğŸŸ¢ğŸŸ¢ Very Fast | ğŸŸ¡ Medium | ğŸ”´ Low | Large-scale network OS discovery |
| **Nmap NSE** | Active | ğŸŸ¢ Fast | ğŸŸ¢ğŸŸ¢ Very High | ğŸ”´ Low | Deep Windows OS/domain info via SMB/RDP |
| **AI (sgpt+hping3)** | Active | ğŸŸ¢ Fast | ğŸŸ¡ Medium | ğŸ”´ Low | Automated command generation |
| **p0f** | Passive | ğŸŸ¡ Slow | ğŸŸ¢ High | ğŸŸ¢ Very High | Pure passive fingerprinting |

> ğŸ“Œ **WNUAN Mnemonic** (from CEH labs): **W**ireshark, **N**map, **U**nicornscan, **A**I, **N**SE â€” the five extended OS discovery methods documented in Module 03.

---

## 14. CEH Exam Traps & Tips

| âš ï¸ Exam Trap | âœ… Correct Understanding |
|-------------|------------------------|
| **Banner grabbing = OS fingerprinting** | âŒ Different techniques â€” banners are text; fingerprinting is TCP/IP stack analysis |
| **Passive fingerprinting is less accurate** | âš ï¸ It can be equally accurate but requires sufficient traffic samples |
| **Active fingerprinting is always stealthy** | âŒ False â€” active sends packets and is detectable |
| **Spoofed banners fool OS fingerprinting** | âŒ False â€” fingerprinting doesn't rely on banners |
| **Nmap OS detection needs no privileges** | âŒ False â€” requires root/admin for raw packet crafting |
| **TTL 64 = Windows** | âŒ False â€” TTL 64 = Linux/macOS; TTL 128 = Windows |
| **Version detection `-sV` = OS detection** | âŒ Different â€” `-sV` finds service versions; `-O` fingerprints the OS |
| **Firewalls don't affect OS detection** | âŒ False â€” packet filtering significantly reduces fingerprint accuracy |
| **p0f is an active scanner** | âŒ False â€” p0f is purely **passive**; it never sends packets |
| **OS detection works without any open port** | âš ï¸ Partially â€” Nmap needs at least one open AND one closed port for best accuracy |
| **Wireshark sends probes to discover the OS** | âŒ False â€” Wireshark is passive; it only analyzes existing traffic |
| **Unicornscan is more accurate than Nmap** | âŒ False â€” Unicornscan is faster but has a smaller OS signature database |
| **NSE smb-os-discovery uses port 3389** | âŒ False â€” SMB uses **port 445**; RDP NTLM info uses port **3389** |
| **AI tools replace the need for scanning tools** | âŒ False â€” AI generates the commands; the underlying tools (Hping3, Nmap) still do the work |

---

## 15. Mnemonics & Quick Recall

### ğŸ§  WNUAN â€” The Five Extended OS Discovery Methods

```
W â†’ Wireshark     (Passive â€” packet analysis, no probes)
N â†’ Nmap          (Active â€” industry standard, -O flag)
U â†’ Unicornscan   (Active â€” high-speed, large networks)
A â†’ AI            (Hybrid â€” automated command generation)
N â†’ NSE           (Active â€” script-based, SMB/RDP deep analysis)
```

### ğŸ§  Passive vs Active Split

```
PASSIVE (stealthy, no packets sent):
  â†’ Wireshark  (manual packet analysis)
  â†’ p0f        (automated passive fingerprinting)

ACTIVE (detectable, probes sent):
  â†’ Nmap -O    (TCP/IP stack probing)
  â†’ Unicornscan (high-speed async probing)
  â†’ Nmap NSE   (protocol-level interrogation)

AI = Hybrid (automates active tools)
```

### ğŸ§  TTL Quick Reference

```
TTL â‰ˆ 128  â†’  Windows (any version)
TTL â‰ˆ 64   â†’  Linux / macOS / Android
TTL â‰ˆ 255  â†’  Cisco IOS / Solaris (network devices)
```

### ğŸ§  NSE Port Memory Aid

```
SMB-OS-Discovery    â†’  Port 445  (SMB)
RDP-NTLM-Info       â†’  Port 3389 (RDP)
445 = S (SMB starts after R in alphabet)
```

---

### ğŸ“‹ Quick Command Reference Card

| Goal | Command |
|------|---------|
| Banner grab via Netcat | `nc -nv <target> <port>` |
| Banner grab via curl | `curl -I http://<target>` |
| Nmap version detection | `nmap -sV <target>` |
| Nmap basic OS detection | `sudo nmap -O <target>` |
| Nmap aggressive OS + version | `sudo nmap -A <target>` |
| Nmap OS with guess fallback | `sudo nmap -O --osscan-guess <target>` |
| Nmap SMB OS discovery | `nmap --script=smb-os-discovery -p 445 <target>` |
| Nmap RDP OS info | `nmap --script=rdp-ntlm-info -p 3389 <target>` |
| Unicornscan TCP range | `unicornscan -mT <target>:1-1024` |
| Passive OS fingerprinting | `sudo p0f -i eth0` |
| p0f from pcap file | `sudo p0f -r capture.pcap` |
| Hping3 ICMP probe | `hping3 -1 <target> --count 10` |
| AI-generated Hping3 | `sgpt --chat scan --shell "Use Hping3 to ICMP scan 10.10.1.11 stop after 10"` |
| OS + version combined | `sudo nmap -O -sV <target>` |

---

*ğŸ“š CEH v13 Â· Module 03: Scanning Networks | Last updated: February 2026*